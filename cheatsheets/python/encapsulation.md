# encapsulation

[Назад][back]

### Инкапсуляция как управление доступом

- **публичный** (public, нет особого синтаксиса, `publicBanana`) — данные доступны всем.
- **защищенный** (protected, одно нижнее подчеркивание в начале названия, `_protectedBanana`).
- **приватный** (private, два нижних подчеркивания в начала названия, `__privateBanana`) — данные доступны только
  объекту/классу которому они принадлежат.

```python
# Публичный
class A:
    text = "публичный"
    def public(self):
        print(f"Это {self.text} метод!")

a = A()
a.public()  # Это публичный метод!

# Защищённый
class B:
    _text = "защищённый"
    def _protected(self):
        print(f"Это {self._text} метод!")

b = B()
b._protected()  # Это защищённый метод!

# Приватный
class C:
    __text = "приватный"
    def __private(self):
        print(f"Это {self.__text} метод!")

c = C()
# c.__private()
# Traceback (most recent call last):
# AttributeError: 'C' object has no attribute '__private'. Did you mean: '_B__private'?

# Нарушение инкапсуляции
c._C__private()  # Это приватный метод!
```

### Зачем нужна инкапсуляция?

- Инкапсуляция помогает в достижении четко определенного взаимодействия в каждом приложении.
- Объектно-ориентированная концепция фокусируется на возможности повторного использования кода в Python.
- Приложения можно безопасно обслуживать. Это обеспечивает гибкость кода за счет правильной организации.
- Способствует плавному взаимодействию с пользователями без каких-либо внутренних сложностей.
- Это улучшает читаемость кода. Любые изменения в одной части кода не помешают другой.
- Инкапсуляция обеспечивает защиту данных и предотвращает случайный доступ к данным.
- Доступ к защищенным данным можно получить с помощью описанных выше методов.

[Назад][back]

[back]: <.> "Назад к оглавлению"