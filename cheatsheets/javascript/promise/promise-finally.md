//------------------------------------------------------ // finally
//------------------------------------------------------ // Вызов .finally(f) похож на .then(f, f), в том смысле, что f
выполнится в любом случае, // когда промис завершится: успешно или с ошибкой.

new Promise((resolve, reject) => { /* сделать что-то, что займёт время, и после вызвать resolve/reject */ })
// выполнится, когда промис завершится, независимо от того, успешно или нет .finally(() => /* остановить индикатор
загрузки */)
.then(result => /* показать результат */, err => /* показать ошибку */);

// Например, здесь результат проходит через finally к then:
new Promise((resolve, reject) => { setTimeout(() => resolve("result"), 2000)
})
.finally(() => alert("Промис завершён"))
.then(result => alert(result)); // <-- .then обработает результат

// А здесь ошибка из промиса проходит через finally к catch:
new Promise((resolve, reject) => { throw new Error("error"); })
.finally(() => alert("Промис завершён"))
.catch(err => alert(err)); // <-- .catch обработает объект ошибки

