//------------------------------------------------------ // Promise
//------------------------------------------------------ // Объект Promise (обещание) представляет из себя специальный
объект, предназначенный для планирования работы над значением, // которое еще не было вычислено (завершение или сбой
асинхронной операции). // Объект Promise представляет из себя абстракцию для управления взаимодействиями с асинхронными
API.

// Начальное состояние любого объекта Promise - pending (ожидание). // Если операция завершена успешно, то объект
Promise изменяет свое состояние на fulfilled (выполнено), // в том случае если операция завершена ошибкой, то объект
Promise изменяет свое состояние на rejected (отклонено).

// Еще один термин settled (решенный) используется для описания состояния объекта Promise, // который изменил свое
состояние на fulfilled (выполнено), или rejected (отклонено).

let promise = newPromise(executor); let executor = function(resolve, reject) { }

// или let promise = new Promise(function(resolve, reject) { // функция-исполнитель (executor)
});

executor // Представляет из себя объект функции, который принимает два аргумента: resolve и reject. // Аргументы
представляют из себя функции, которые могут быть вызваны по завершению операции, // первый аргумент вызывает успешное
выполнение обещания, а второй отклоняет его.

// У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
state // («состояние») вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове
resolve или на "rejected" («выполнено с ошибкой») при вызове reject. result // («результат») вначале undefined, далее
изменяется на value при вызове resolve(value) или на error при вызове reject(error).

// Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):
let promise = new Promise(function(resolve, reject) { // эта функция выполнится автоматически, при вызове new Promise

// через 1 секунду сигнализировать, что задача выполнена с результатом "done"
setTimeout(() => resolve("done"), 1000); });

// А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
let promise = new Promise(function(resolve, reject) { // спустя 1 секунду будет сообщено, что задача выполнена с ошибкой
setTimeout(() => reject(new Error("Whoops!")), 1000); });

// Может быть что-то одно: либо результат, либо ошибка:
let promise = new Promise(function(resolve, reject) { resolve("done");

reject(new Error("…")); // игнорируется setTimeout(() => resolve("…")); // игнорируется });

//------------------------------------------------------ // Потребители: then, catch, finally
//------------------------------------------------------ // Свойства state и result – это внутренние свойства объекта
Promise и мы не имеем к ним прямого доступа. // Для обработки результата следует использовать методы
.then/.catch/.finally.

//------------------------------------------------------ // Методы объекта Promise
//------------------------------------------------------ Promise.all()     // Возвращает объект Promise, который имеет
состояние fulfilled (успешное выполнение) в том случае, когда все переданные объекты Promise в аргументе имеют состояние
fulfilled (успешное выполнение), или когда аргумент не содержит объектов Promise. Возвращает объект Promise, который
имеет состояние rejected (выполнение отклонено) в том случае, когда один из переданных объектов изменил своё состояние
на rejected (выполнение отклонено). Promise.catch()   // Добавляет обработчик или обработчики, которые будут вызваны при
изменении состояния объекта Promise на rejected (выполнение отклонено). Promise.finally() // Добавляет обработчик,
который будет вызван вне зависимости от того с каким результатом объект Promise был выполнен (rejected - выполнение
отклонено, или fulfilled - успешное выполнение). Promise.race()    // Возвращает объект Promise, который имеет состояние
rejected (выполнение отклонено), или fulfilled (успешное выполнение). Результат выполнения зависит от того, с каким
результатом завершается выполнение первого из переданных объектов Promise. Promise.reject()  // Возвращает объект
Promise, который был отклонен по указанной причине (изменяет состояние объекта Promise на rejected - выполнение
отклонено). Promise.resolve() // Возвращает объект Promise, который был успешно выполнен с заданным значением (изменяет
состояние объекта Promise на fulfilled - успешное выполнение). Promise.then()    // Добавляет обработчик, или
обработчики, вызываемые когда объект Promise имеет состояние fulfilled (успешное выполнение), или rejected (выполнение
отклонено).

//------------------------------------------------------ // Пример: loadScript
//------------------------------------------------------ // Давайте вспомним, как выглядел вариант с колбэками:
function loadScript(src, callback) { let script = document.createElement('script'); script.src = src;

script.onload = () => callback(null, script); script.onerror = () => callback(new
Error(`Ошибка загрузки скрипта ${src}`));

document.head.append(script); }

// Теперь перепишем её, используя Promise. function loadScript(src) { return new Promise(function(resolve, reject) { let
script = document.createElement('script'); script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);

}); }

// Применение:
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
script => alert(`${script.src} загружен!`), error => alert(`Ошибка: ${error.message}`)
);

promise.then(script => alert('Ещё один обработчик...'));





