//------------------------------------------------------ // Обработка ошибок, "try..catch"
//------------------------------------------------------

// Пример без ошибок: выведет alert (1) и (2):
try {

alert('Начало блока try'); // (1) <--

// ...код без ошибок

alert('Конец блока try'); // (2) <--

} catch(err) {

alert('Catch игнорируется, так как нет ошибок'); // (3)

}

// Пример с ошибками: выведет (1) и (3):
try {

alert('Начало блока try'); // (1) <--

lalala; // ошибка, переменная не определена!

alert('Конец блока try (никогда не выполнится)'); // (2)

} catch(err) {

alert(`Возникла ошибка!`); // (3) <--

}

//------------------------------------------------------ // try..catch работает синхронно
//------------------------------------------------------ // Исключение, которое произойдёт в коде, запланированном «на
будущее», например в setTimeout, try..catch не поймает:
try { setTimeout(function() { noSuchVariable; // скрипт упадёт тут }, 1000); } catch (e) { alert( "не сработает" ); }

// Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:
setTimeout(function() { try { noSuchVariable; // try..catch обрабатывает ошибку!
} catch { alert( "ошибка поймана!" ); } }, 1000);

//------------------------------------------------------ // Объект ошибки
//------------------------------------------------------ // Когда возникает ошибка, JavaScript генерирует объект,
содержащий её детали. // Затем этот объект передаётся как аргумент в блок catch:
try { // ... } catch(err) { // <-- объект ошибки, можно использовать другое название вместо err // ... }

// Для всех встроенных ошибок этот объект имеет два основных свойства:
name // Имя ошибки. Например, для неопределённой переменной это "ReferenceError". message // Текстовое сообщение о
деталях ошибки. stack // Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов,
которые привели к ошибке. Используется в целях отладки.

try { lalala; // ошибка, переменная не определена!
} catch(err) { alert(err.name); // ReferenceError alert(err.message); // lalala is not defined alert(err.stack); //
ReferenceError: lalala is not defined at (...стек вызовов)

// Можем также просто вывести ошибку целиком // Ошибка приводится к строке вида "name: message"
alert(err); // ReferenceError: lalala is not defined }

// Если нам не нужны детали ошибки, в catch можно её пропустить:
try { // ... } catch { //  <-- без (err)
// ... }

//------------------------------------------------------ // Оператор «throw». Генерация собственных ошибок
//------------------------------------------------------ let error = new Error(message); // или let error = new
SyntaxError(message); let error = new ReferenceError(message); // ...

let json = '{ "age": 30 }'; // данные неполны try { let user = JSON.parse(json); // <-- выполнится без ошибок

if (!user.name) { throw new SyntaxError("Данные неполны: нет имени"); // (*)
}

alert( user.name ); } catch(e) { alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени }

//------------------------------------------------------ // Проброс исключения
//------------------------------------------------------ let json = '{ "age": 30 }'; // данные неполны try { let user =
JSON.parse(json);

if (!user.name) { throw new SyntaxError("Данные неполны: нет имени"); }

blabla(); // неожиданная ошибка alert( user.name ); } catch(e) { if (e.name == "SyntaxError") { alert( "JSON Error: " +
e.message ); } else { throw e; // проброс (*)
} }

// Ещё одного уровня try..catch:
function readData() { let json = '{ "age": 30 }';

try { // ... blabla(); // ошибка!
} catch (e) { // ... if (e.name != 'SyntaxError') { throw e; // проброс исключения (не знаю как это обработать)
} } }

try { readData(); } catch (e) { alert( "Внешний catch поймал: " + e ); // поймал!
}

//------------------------------------------------------ // try…catch…finally
//------------------------------------------------------ try { // ... пробуем выполнить код... } catch(e) { // ...
обрабатываем ошибки ... } finally { // ... выполняем всегда ... }

// У кода есть два пути выполнения:
// 1. Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try -> catch -> finally. // 2. Если ответите
отрицательно, то try -> finally.

let num = +prompt("Введите положительное целое число?", 35)
let diff, result;

function fib(n) { if (n < 0 || Math.trunc(n) != n) { throw new Error("Должно быть целое неотрицательное число"); }
return n <= 1 ? n : fib(n - 1) + fib(n - 2); }

let start = Date.now();

try { result = fib(num); } catch (e) { result = 0; } finally { diff = Date.now() - start; }

alert(result || "возникла ошибка"); alert( `Выполнение заняло ${diff}ms` );

//------------------------------------------------------ // finally и return
//------------------------------------------------------ // Блок finally срабатывает при любом выходе из try..catch, в
том числе и return.

function func() { try { return 1; } catch (e) { /* ... */ } finally { alert( 'finally' ); } }

alert( func() ); // сначала срабатывает alert из finally, а затем этот код

//------------------------------------------------------ // try..finally
//------------------------------------------------------ // Мы применяем её, когда не хотим здесь обрабатывать ошибки (
пусть выпадут), // но хотим быть уверены, что начатые процессы завершились.

function func() { // начать делать что-то, что требует завершения (например, измерения)
try { // ... } finally { // завершить это, даже если все упадёт } }

//------------------------------------------------------ // Глобальный catch
//------------------------------------------------------ window.onerror = function(message, url, line, col, error) { //
... }; message // Сообщение об ошибке. url // URL скрипта, в котором произошла ошибка. line, col // Номера строки и
столбца, в которых произошла ошибка. error // Объект ошибки.

<script>
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n В ${line}:${col} на ${url}`);
  };

  function readData() {
    badFunc(); // Ой, что-то пошло не так!
  }

  readData();
</script>




